"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GitHubProvider = exports.BaseGitHubProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _electronBuilderHttp;

function _load_electronBuilderHttp() {
    return _electronBuilderHttp = require("electron-builder-http");
}

var _CancellationToken;

function _load_CancellationToken() {
    return _CancellationToken = require("electron-builder-http/out/CancellationToken");
}

var _publishOptions;

function _load_publishOptions() {
    return _publishOptions = require("electron-builder-http/out/publishOptions");
}

var _path = _interopRequireWildcard(require("path"));

var _url;

function _load_url() {
    return _url = require("url");
}

var _api;

function _load_api() {
    return _api = require("./api");
}

var _GenericProvider;

function _load_GenericProvider() {
    return _GenericProvider = require("./GenericProvider");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class BaseGitHubProvider extends (_api || _load_api()).Provider {
    constructor(options, baseHost) {
        super();
        this.options = options;
        const baseUrl = (0, (_url || _load_url()).parse)(`${options.protocol || "https"}://${options.host || baseHost}`);
        this.baseUrl = {
            protocol: baseUrl.protocol,
            hostname: baseUrl.hostname,
            port: baseUrl.port
        };
    }
}
exports.BaseGitHubProvider = BaseGitHubProvider;
class GitHubProvider extends BaseGitHubProvider {
    constructor(options, updater) {
        super(options, "github.com");
        this.options = options;
        this.updater = updater;
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const basePath = _this.basePath;
            const cancellationToken = new (_CancellationToken || _load_CancellationToken()).CancellationToken();
            const xElement = require("xelement");
            const feedXml = yield (0, (_electronBuilderHttp || _load_electronBuilderHttp()).request)(Object.assign({
                path: `${basePath}.atom`,
                headers: Object.assign({}, _this.requestHeaders, { Accept: "application/xml" })
            }, _this.baseUrl), cancellationToken);
            const feed = new xElement.Parse(feedXml);
            const latestRelease = feed.element("entry");
            if (latestRelease == null) {
                throw new Error(`No published versions on GitHub`);
            }
            let version;
            try {
                if (_this.updater.allowPrerelease) {
                    version = latestRelease.element("link").getAttr("href").match(/\/tag\/v?([^\/]+)$/)[1];
                } else {
                    version = yield _this.getLatestVersionString(basePath, cancellationToken);
                }
            } catch (e) {
                throw new Error(`Cannot parse releases feed: ${e.stack || e.message},\nXML:\n${feedXml}`);
            }
            let result;
            const channelFile = (0, (_api || _load_api()).getChannelFilename)((0, (_api || _load_api()).getDefaultChannelName)());
            const requestOptions = Object.assign({ path: _this.getBaseDownloadPath(version, channelFile), headers: _this.requestHeaders || undefined }, _this.baseUrl);
            try {
                result = yield (0, (_electronBuilderHttp || _load_electronBuilderHttp()).request)(requestOptions, cancellationToken);
            } catch (e) {
                if (!_this.updater.allowPrerelease) {
                    if (e instanceof (_electronBuilderHttp || _load_electronBuilderHttp()).HttpError && e.response.statusCode === 404) {
                        throw new Error(`Cannot find ${channelFile} in the latest release artifacts (${(0, (_api || _load_api()).formatUrl)(requestOptions)}): ${e.stack || e.message}`);
                    }
                }
                throw e;
            }
            (0, (_GenericProvider || _load_GenericProvider()).validateUpdateInfo)(result);
            if ((0, (_api || _load_api()).getCurrentPlatform)() === "darwin") {
                result.releaseJsonUrl = `${(0, (_publishOptions || _load_publishOptions()).githubUrl)(_this.options)}/${requestOptions.path}`;
            }
            if (result.releaseName == null) {
                result.releaseName = latestRelease.getElementValue("title");
            }
            if (result.releaseNotes == null) {
                result.releaseNotes = latestRelease.getElementValue("content");
            }
            return result;
        })();
    }
    getLatestVersionString(basePath, cancellationToken) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const requestOptions = Object.assign({
                path: `${basePath}/latest`,
                headers: Object.assign({}, _this2.requestHeaders, { Accept: "application/json" })
            }, _this2.baseUrl);
            try {
                // do not use API to avoid limit
                const releaseInfo = yield (0, (_electronBuilderHttp || _load_electronBuilderHttp()).request)(requestOptions, cancellationToken);
                return releaseInfo.tag_name.startsWith("v") ? releaseInfo.tag_name.substring(1) : releaseInfo.tag_name;
            } catch (e) {
                throw new Error(`Unable to find latest version on GitHub (${(0, (_api || _load_api()).formatUrl)(requestOptions)}), please ensure a production release exists: ${e.stack || e.message}`);
            }
        })();
    }
    get basePath() {
        return `/${this.options.owner}/${this.options.repo}/releases`;
    }
    getUpdateFile(versionInfo) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if ((0, (_api || _load_api()).getCurrentPlatform)() === "darwin") {
                return versionInfo;
            }
            // space is not supported on GitHub
            const name = versionInfo.githubArtifactName || _path.posix.basename(versionInfo.path).replace(/ /g, "-");
            return {
                name: name,
                url: (0, (_api || _load_api()).formatUrl)(Object.assign({ path: _this3.getBaseDownloadPath(versionInfo.version, name) }, _this3.baseUrl)),
                sha2: versionInfo.sha2
            };
        })();
    }
    getBaseDownloadPath(version, fileName) {
        return `${this.basePath}/download/${this.options.vPrefixedTagName === false ? "" : "v"}${version}/${fileName}`;
    }
}
exports.GitHubProvider = GitHubProvider; //# sourceMappingURL=GitHubProvider.js.map